

#include "/mestrado/projetos/scp/include/scp.includes.h"



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fgerNewCurrentSolution
//
// Description: Tabu Search function
//
// Parameters:  nElements           - number of Elements
//              nSubSets            - number of SubSets
//              psubSets            - pointer to the class subSet
//              pelements           - pointer to the class element
//              pcurrentSolution    - current solution used to create a new solution
//              plistTabu           - tabu list
//              plistMoviment       - list with moviments of an interaction
//
// Output:      newSolution         - new solution generated by this function 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
coveringResult *fgerNewCurrentSolution( int nElements, int nSubSets, subSet *psubSets,  element *pelements, coveringResult *pcurrentSolution, int *phasSolution, int *piNextSolution, int iTotalSolution, st_coveringResultSupport *pst_coveringResultSupport )
{
    int inumOfCovering = pcurrentSolution[0].fgetNumOfCovering();          // Number of covering
    int ihasSolution   = *phasSolution;                                    // 
    int iNextSolution  = *piNextSolution;									   
    coveringResult *newSolution  = new coveringResult[1];                  // New solution
    int iSubSetSelected;						   // SubSet selected with irandomNumber number
    int iNumberOfCovering;                                                 // Number of Elements covered by this SubSet	
    int *subSets                 = new int[inumOfCovering];
    int *elements                = new int[inumOfCovering];
    int *weight                  = new int[inumOfCovering];
    int *subSetsVisited          = new int[nSubSets];
    int iNewWeight               = 0;
    int iSubSetRead              = 0;
    int iQtdChanged              = 0;
    int iQdtChecked              = 0;
									   

    // Get all SubSets of current solution
    subSets  = pcurrentSolution[0].fgetSubSets();
    elements = pcurrentSolution[0].fgetElements();
    weight   = pcurrentSolution[0].fgetWeight();

    // Select SubSet with random number (irandomNumber) and get total covering (iTotalElementsCovered) by this SubSet.
    iSubSetSelected=pst_coveringResultSupport[iNextSolution].SubSet;
    iNumberOfCovering=pst_coveringResultSupport[iNextSolution].iTotalElementsCovered;

    // New solution receives the current solution
    newSolution[0] = pcurrentSolution[0];

    // Get all Elements covered by the SubSet
    int j = 0;

    // Loop to Number of Covering (iNumberOfCovering) of a SubSet and Number of Covering to the Solution
    while(j<inumOfCovering)    
    {

        // Found Elements covered by SubSetSelected
        if(iSubSetSelected==subSets[j])                
        {

           iSubSetRead++;

           // Get number of SubSets for this Element
	   int numSetsPerElement = pelements[(elements[j]-1)].fgetNumOfSets(); 

	   int *pSetsPerElement  = new int[numSetsPerElement];
	   int *pSetsPerElementChecked  = new int[numSetsPerElement];

           // Get all SubSets for this Element
	   pSetsPerElement = pelements[(elements[j]-1)].fgetSubSets();         

           // Get all situations of SubSets for this Element
	   pSetsPerElementChecked = pelements[(elements[j]-1)].fgetisSubSetChecked();         

           // Reading all Subsets for Element and looking for a new one
           // differente from the current, if possible.
	   for(int i=0;i<numSetsPerElement;i++)         
	   {                                            

	       // Found the SubSet and it must be diffent from current
               if(pSetsPerElement[i]!=iSubSetSelected)  
	       {
		  // Get the weight for this SubSet   
                  iNewWeight = psubSets[(pSetsPerElement[i]-1)].fgetWeight(); 
                         
		  newSolution[0].fupdWeight(iNewWeight,j);
	          newSolution[0].fupdSubSet(pSetsPerElement[i],j);

		  if(pSetsPerElementChecked[i]==0)
	          {
		     pelements[(elements[j]-1)].fupdisSubSetChecked(1,i);

		     iQdtChecked = pelements[(elements[j]-1)].fgetQtdChecked();
		     iQdtChecked++;
		     pelements[(elements[j]-1)].fsetQtdChecked(iQdtChecked);
		     iQdtChecked = pelements[(elements[j]-1)].fgetQtdChecked();
// std::cout << "Elemento " << pelements[(elements[j]-1)].fgetElement() << " - iSubSetSelected " << iSubSetSelected << " - iQdtChecked " << iQdtChecked << "\n";
 	             break;
                  }


	       }
	       else
		  if(pSetsPerElement[i]==iSubSetSelected && pSetsPerElementChecked[i]==0)
		  {
		     pelements[(elements[j]-1)].fupdisSubSetChecked(1,i);
		     iQdtChecked = pelements[(elements[j]-1)].fgetQtdChecked();
		     iQdtChecked++;
		     pelements[(elements[j]-1)].fsetQtdChecked(iQdtChecked);
		  }
	   }

	   // It means that all SubSets of Element were changed
           iQdtChecked = pelements[(elements[j]-1)].fgetQtdChecked();
// std::cout << "Elemento " << pelements[(elements[j]-1)].fgetElement() << " - iSubSetSelected " << iSubSetSelected << " - iQdtChecked " << iQdtChecked << "\n";
	   if( iQdtChecked == numSetsPerElement )
	      pelements[(elements[j]-1)].fsetisAllSubSetChecked(1);

	   delete pSetsPerElement;
	   delete pSetsPerElementChecked;
	   // At the end of this looping we´ll have a new SubSet new for Element.

	}

	// Read all covering of the iSubSetSelected
	if( iNumberOfCovering == iSubSetRead )
	    break;

        j++;

    }

    // Checking if still has solution
    *phasSolution = 1;   
    iQtdChanged   = 1;
    j = 0;
    while(j<inumOfCovering)    
    {
       if(pelements[(elements[j]-1)].fgetisAllSubSetChecked()==1)
       {
	  iQtdChanged++;
       }
       j++;
    }

    if(iQtdChanged==inumOfCovering)
      *phasSolution = 0;   

    iNextSolution++;
    if(iNextSolution==iTotalSolution)
    {    
      if(*phasSolution == 1)
         *piNextSolution = 0;
    }
    else
      *piNextSolution = iNextSolution;


    /////////////////////////////////////////////////////
    // Calculate the Total Weight and Total SubSets used
    int *newSubSets = new int[inumOfCovering];
    int *newWeight  = new int[inumOfCovering];
    int iTotWeight  = 0;
    int iTotSetSub  = 0;

    newSubSets = newSolution[0].fgetSubSets();
    newWeight  = newSolution[0].fgetWeight();

    // Set all SubSetsVisited with 0
    for(int i=0;i<nSubSets;i++) subSetsVisited[i]=0;

    for(int i=0;i<inumOfCovering;i++)
    {
       if( subSetsVisited[ (newSubSets[i]-1) ] == 0 )
       {
           subSetsVisited[ (newSubSets[i]-1) ] = 1;
           iTotSetSub++;
	   iTotWeight = iTotWeight + newWeight[i];
       }
    }
     
    delete newSubSets;
    delete newWeight;

    delete subSets;
    delete elements;
    delete weight;
    delete subSetsVisited;

    // Update the Total Weight and Total SubSets used
    newSolution[0].fsetTotalWeight(iTotWeight);
    newSolution[0].fsetTotalSubSetsUsed(iTotSetSub);
    /////////////////////////////////////////////////////

    return(newSolution);
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fgerNewCurrentSolutionGrasp
//
// Description: Grasp function
//
// Parameters:  nElements           - number of Elements
//              nSubSets            - number of SubSets
//              psubSets            - pointer to the class subSet
//              pelements           - pointer to the class element
//              pcurrentSolution    - current solution used to create a new solution
//              plistTabu           - tabu list
//              plistMoviment       - list with moviments of an interaction
//
// Output:      newSolution         - new solution generated by this function 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
coveringResult *fgerNewCurrentSolutionGrasp( int nElements, int nSubSets, subSet *psubSets,  element *pelements, coveringResult *pcurrentSolution, int iposRand, st_coveringResultSupport *pst_coveringResultSupport )
{
    int inumOfCovering = pcurrentSolution[0].fgetNumOfCovering();         
    coveringResult *newSolution  = new coveringResult[1];               
    int iSubSetSelected;					
    int iNumberOfCovering;                                     
    int *subSets                 = new int[inumOfCovering];
    int *elements                = new int[inumOfCovering];
    int *weight                  = new int[inumOfCovering];
    int *subSetsVisited          = new int[nSubSets];
    int iNewWeight               = 0;
    int iSubSetRead              = 0;
									   

    // Get all SubSets of current solution
    subSets  = pcurrentSolution[0].fgetSubSets();
    elements = pcurrentSolution[0].fgetElements();
    weight   = pcurrentSolution[0].fgetWeight();


    // Select SubSet with random number (irandomNumber) and get total covering (iTotalElementsCovered) by this SubSet.
    iSubSetSelected=pst_coveringResultSupport[iposRand].SubSet;
    iNumberOfCovering=pst_coveringResultSupport[iposRand].iTotalElementsCovered;

    // New solution receives the current solution
    newSolution[0] = pcurrentSolution[0];

    // Get all Elements covered by the SubSet
    int j = 0;

    // Loop to Number of Covering (iNumberOfCovering) of a SubSet and Number of Covering to the Solution
    while(j<inumOfCovering)    
    {

        // Found Elements covered by SubSetSelected
        if(iSubSetSelected==subSets[j])                
        {

           iSubSetRead++;

           // Get number of SubSets for this Element
	   int numSetsPerElement = pelements[(elements[j]-1)].fgetNumOfSets(); 

	   int *pSetsPerElement  = new int[numSetsPerElement];

           // Get all SubSets for this Element
	   pSetsPerElement = pelements[(elements[j]-1)].fgetSubSets();         

           // Reading all Subsets for Element and looking for a new one
           // differente from the current, if possible.
	   for(int i=0;i<numSetsPerElement;i++)         
	   {                                            

	       // Found the SubSet and it must be diffent from current
               if(pSetsPerElement[i]!=iSubSetSelected)  
	       {

		  // Get the weight for this SubSet   
                  iNewWeight = psubSets[(pSetsPerElement[i]-1)].fgetWeight(); 
                         
		  newSolution[0].fupdWeight(iNewWeight,j);
	          newSolution[0].fupdSubSet(pSetsPerElement[i],j);

 	          break;

	       }

	   }
	   delete pSetsPerElement;
	   // At the end of this looping we´ll have a new SubSet new for Element.

	}

	// Read all covering of the iSubSetSelected
	if( iNumberOfCovering == iSubSetRead )
	    break;

        j++;

    }

    /////////////////////////////////////////////////////
    // Calculate the Total Weight and Total SubSets used
    int *newSubSets = new int[inumOfCovering];
    int *newWeight  = new int[inumOfCovering];
    int iTotWeight  = 0;
    int iTotSetSub  = 0;

    newSubSets = newSolution[0].fgetSubSets();
    newWeight  = newSolution[0].fgetWeight();

    // Set all SubSetsVisited with 0
    for(int i=0;i<nSubSets;i++) subSetsVisited[i]=0;

    for(int i=0;i<inumOfCovering;i++)
    {
       if( subSetsVisited[ (newSubSets[i]-1) ] == 0 )
       {
           subSetsVisited[ (newSubSets[i]-1) ] = 1;
           iTotSetSub++;
	   iTotWeight = iTotWeight + newWeight[i];
       }
    }
     
    delete newSubSets;
    delete newWeight;

    delete subSets;
    delete elements;
    delete weight;
    delete subSetsVisited;

    // Update the Total Weight and Total SubSets used
    newSolution[0].fsetTotalWeight(iTotWeight);
    newSolution[0].fsetTotalSubSetsUsed(iTotSetSub);
    /////////////////////////////////////////////////////

    return(newSolution);
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fgerNewCurrentSolutionTabu
//
// Description: Tabu Search function
//
// Parameters:  nElements           - number of Elements
//              nSubSets            - number of SubSets
//              psubSets            - pointer to the class subSet
//              pelements           - pointer to the class element
//              pcurrentSolution    - current solution used to create a new solution
//              plistTabu           - tabu list
//              plistMoviment       - list with moviments of an interaction
//              ipElementsCovered   - Elements that are covered
//              iNumSubSetUsed      - Total SubSets used in initial solution
//
// Output:      newSolution         - new solution generated by this function 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
coveringResult *fgerNewCurrentSolutionTabu( int nElements, int nSubSets, subSet *psubSets,  element *pelements, coveringResult *pcurrentSolution, int *plistTabu, int *plistMoviment, int iMaxSubSet  )
{
    struct st_coveringResultSupport pst_coveringResultSupport[nSubSets];   // Support structure with SubSet and number of covering
    int inumOfCovering = pcurrentSolution[0].fgetNumOfCovering();          // Number of covering
    int irandomNumber  = 0;                                                // Random number used to choice the SubSet 
    coveringResult *newSolution  = new coveringResult[1];                  // New solution
    int iSubSetSelected;						   // SubSet selected with irandomNumber number
    int iNumberOfCovering;                                                 // Number of Elements covered by this SubSet	
    int *subSets                 = new int[inumOfCovering];
    int *elements                = new int[inumOfCovering];
    int *weight                  = new int[inumOfCovering];
    int *subSetsVisited          = new int[nSubSets];
    int iNewWeight               = 0;
    int iSubSetRead              = 0;
									   

    // Get all SubSets of current solution
    subSets  = pcurrentSolution[0].fgetSubSets();
    elements = pcurrentSolution[0].fgetElements();
    weight   = pcurrentSolution[0].fgetWeight();

    // Set all SubSetsVisited with 0
    for(int i=0;i<nSubSets;i++) subSetsVisited[i]=0;

    // Load structure support with SubSets and total covering by SubSet
    fgerResultSupport( nSubSets, psubSets, pcurrentSolution, pst_coveringResultSupport ); 

    // Get random number to select a SubSet in pst_coveringResultSupport
    for(int i=0;i<10;i++)
    {
       irandomNumber = fgerRandomic( iMaxSubSet ); 
       iSubSetSelected=pst_coveringResultSupport[irandomNumber].SubSet;
       if(iSubSetSelected!=0)
          break;
    }

    // Select SubSet with random number (irandomNumber) and get total covering (iTotalElementsCovered) by this SubSet.
    iSubSetSelected=pst_coveringResultSupport[irandomNumber].SubSet;
    iNumberOfCovering=pst_coveringResultSupport[irandomNumber].iTotalElementsCovered;


    // New solution receives the current solution
    newSolution[0] = pcurrentSolution[0];

    // Get all Elements covered by the SubSet
    int j = 0;

    // Loop to Number of Covering (iNumberOfCovering) of a SubSet
    while(j<inumOfCovering)    
    {


	// Found in solution the SubSetSelected
        if(iSubSetSelected==subSets[j])                
        {

             iSubSetRead++;

             // Get number of SubSets for this Element
	     int numSetsPerElement = pelements[(elements[j]-1)].fgetNumOfSets(); 

             // Get all SubSets for this Element
	     int *pSetsPerElement  = new int[numSetsPerElement];
 	     pSetsPerElement = pelements[(elements[j]-1)].fgetSubSets();         

             // Reading all Subsets for Element and looking for a new one
             // differente from the current, if possible.
	     for(int i=0;i<numSetsPerElement;i++)         
	     {                                            

		    // Found the SubSet and:
		    //   - it must be diffent from current	
		    //   - it doesn't exist in plistTabu ( 0 in position of correspoding SubSet )
                    if(pSetsPerElement[i]!=iSubSetSelected && plistTabu[(pSetsPerElement[i]-1)]==0 )
		    {

			 // Get the weight for this SubSet   
                         iNewWeight = psubSets[(pSetsPerElement[i]-1)].fgetWeight(); 
		         newSolution[0].fupdWeight(iNewWeight,j);
			 newSolution[0].fupdSubSet(pSetsPerElement[i],j);

			 // Set to 1 this SubSet Moviment
			 plistMoviment[(pSetsPerElement[i]-1)] = 1;
  			 break;

		    }
			
	      }
	      // At the end of this looping we´ll have a new SubSet new for Element.

	}

	// Read all covering of the iSubSetSelected
        if( iNumberOfCovering == iSubSetRead )
	    break;

        j++;

    }


    /////////////////////////////////////////////////////
    // Calculate the Total Weight and Total SubSets used
    int *newSubSets = new int[inumOfCovering];
    int *newWeight  = new int[inumOfCovering];
    int iTotWeight  = 0;
    int iTotSetSub  = 0;

    newSubSets = newSolution[0].fgetSubSets();
    newWeight  = newSolution[0].fgetWeight();

    for(int i=0;i<inumOfCovering;i++)
    {
       if( subSetsVisited[ (newSubSets[i]-1) ] == 0 )
       {
           subSetsVisited[ (newSubSets[i]-1) ] = 1;
           iTotSetSub++;
	   iTotWeight = iTotWeight + newWeight[i];
       }
    }

    delete newSubSets;
    delete newWeight;

    // Update the Total Weight and Total SubSets used
    newSolution[0].fsetTotalWeight(iTotWeight);
    newSolution[0].fsetTotalSubSetsUsed(iTotSetSub);
    /////////////////////////////////////////////////////


    return(newSolution);
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fCalcCust 
//
// Description: Calculate the solution cust
//
// Parameters:  pSolution   - solution of covering problem
//              
// Output:      iCustValue  - Cust value
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int fCalcCust( coveringResult *pSolution )
{
    int iCustValue = pSolution[0].fgetTotalWeight();

    return(iCustValue);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fupdateListTabu
//
// Description: Update Tabu List
//
// Parameters:  nSubSets     - number of SubSets
//              listTabu     - list Tabu corresponding to the SubSets
//              listMoviment - Moviments of the last interaction
//              iDeadline    - Deadline for all Tabus define in envirionment variable DEADLINE
//              
// Output:      
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void fupdateListTabu( int nSubSets, int *plistTabu, int *plistMoviment, int iDeadline )
{
    for(int i=0;i<nSubSets;i++)
       if(plistMoviment[i]==1)           // if a specific SubSet had a moviment
           plistTabu[i]=(iDeadline+1);   // This process puts iDeadline+1 because in this interaction the deadlines of
					 // Tabu list will decrease 1
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fupdateDeadlineLT
//
// Description: Update Deadline Tabu List
//
// Parameters:  nSubSets     - number of SubSets
//              listTabu     - list Tabu corresponding to the SubSets
//              
// Output:      
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void fupdateDeadlineLT( int nSubSets, int *plistTabu )
{
    for(int i=0;i<nSubSets;i++)
       if(plistTabu[i]>0)                  // Only decrease if listTabu item is greater than 0
           plistTabu[i]=(plistTabu[i]-1);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fprintElementsSubSets
//
// Description: This function prints all SUBSETS and ELEMENTS.
//
// Parameters:  nElements     - number of Elements
//              nSubSets      - number of SubSets
//              psubSets      - pointer to the class subSet
//              pelements     - pointer to the class element
//
// Output:      NA
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void fprintElementsSubSets( int nElements, int nSubSets, subSet *psubSets,  element *pelements )
{
        int     iCurrentSubSet=1;                    // Current Subset						   
        int     iCurrentElement=1;                   // Current Element
        int     iCurrentPositionSubSet=0;            // Current Position SubSet readen for a specific Element
	int     iTotalSubSets=0;                     // Total SubSets for a specific Element
        int     iSubSet=0;                           // SubSet	
	int     iTotCost=0;                          // Total cost to cover a Elememt					     

        std::cout << "***********************************************************************\n";

	std::cout << "SubSets and its Weight" << "\n";
	std::cout << "----------------------" << "\n";
        iCurrentSubSet=1;
        while( iCurrentSubSet <= nSubSets )
	{
   	   std::cout << "    SubSet: " << psubSets[(iCurrentSubSet-1)].fgetNumSubSet() << " - Weight: " << psubSets[(iCurrentSubSet-1)].fgetWeight() << " - Number of Elements: " << psubSets[(iCurrentSubSet-1)].fgetnumOfElements() << " - Coverage Cost: " << std::fixed << std::setprecision(2) << psubSets[(iCurrentSubSet-1)].fgetCoverageCost() << "\n";
//   	   std::cout << "    SubSet: " << psubSets[(iCurrentSubSet-1)].fgetNumSubSet() << " - Weight: " << psubSets[(iCurrentSubSet-1)].fgetWeight() << " - Number of Elements: " << psubSets[(iCurrentSubSet-1)].fgetnumOfElements() << " - Coverage Cost: " << std::fixed << std::setprecision(2) << static_cast<float>(psubSets[(iCurrentSubSet-1)].fgetWeight())/psubSets[(iCurrentSubSet-1)].fgetnumOfElements() << "\n";
	   iCurrentSubSet++;
	}

        std::cout << "***********************************************************************\n";

	std::cout << "Elements and its SubSets" << "\n";
	std::cout << "------------------------" << "\n";
	iCurrentElement=1;
        while( iCurrentElement <= nElements  ) 
	{
	   iTotalSubSets=pelements[(iCurrentElement-1)].fgetNumOfSets();
	   int *piSubSet = new int[iTotalSubSets];
	   piSubSet = pelements[(iCurrentElement-1)].fgetSubSets();
           std::cout <<  "    Current Element: " << pelements[(iCurrentElement-1)].fgetElement() << " - Total SubSets: " << iTotalSubSets << "\n";
           iCurrentPositionSubSet=1;
	   iTotCost=0;
	   while(iCurrentPositionSubSet<=iTotalSubSets)
           {
	      iSubSet=piSubSet[(iCurrentPositionSubSet-1)];
	      iTotCost = iTotCost + psubSets[(iSubSet-1)].fgetWeight();
              std::cout << "      ->  SubSet: " << piSubSet[(iCurrentPositionSubSet-1)] << " - Weight: " << psubSets[(iSubSet-1)].fgetWeight() << "\n";

              iCurrentPositionSubSet++;
	   }
           std::cout <<    "      ->  Tot Cost: " << iTotCost << "\n";
	   std::cout << "\n";
           iCurrentElement++;
	}

        std::cout << "***********************************************************************\n";
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fprintSolution
//
// Description: Print the result of a specific solutcion
//
// Parameters:  Heuristics      - description of used Heuristic
//              pcoveringResult - covering result
//
// Output:      NA
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void fprintSolution( const std::string& Heuristics, coveringResult *pcoveringResult )
{
    int inumOfCovering    = pcoveringResult[0].fgetNumOfCovering();
    int *elementCovered   = new int[inumOfCovering];
    int *subSets          = new int[inumOfCovering];
    int *weights          = new int[inumOfCovering];
    int iTotalWeight      = pcoveringResult[0].fgetTotalWeight();
    int iTotalSubSetsUsed = pcoveringResult[0].fgetTotalSubSetsUsed();

    elementCovered = pcoveringResult[0].fgetElements();
    subSets = pcoveringResult[0].fgetSubSets();
    weights = pcoveringResult[0].fgetWeight();

    std::cout << std::left;
    std::cout << "\n";
    std::cout << "***********************************************************************\n";
    std::cout << Heuristics << "\n";
    std::cout << "-------------------------------" << "\n";
    std::cout << std::setw(14) << "Element";
    std::cout << std::setw(14) << "SubSet";
    std::cout << std::setw(14) << "Weight" << "\n";
    std::cout << std::setw(14) << "-------";
    std::cout << std::setw(14) << "------";
    std::cout << std::setw(14) << "------" << "\n";

    for(int i=0;i<inumOfCovering;i++)
    {
       std::cout << std::setw(14) << elementCovered[i];
       std::cout << std::setw(14) << subSets[i];
       std::cout << std::setw(14) << weights[i] << "\n";
    }

    std::cout << "\n";
    std::cout << "Total SubSets used -> " << iTotalSubSetsUsed << "\n";
    std::cout << "Total Weight -> " << iTotalWeight << "\n";
    std::cout << "***********************************************************************\n";
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: compareStructsDesc & compareCoverageCostAsc
//
// Description: Functions used to order struct fields
//
// Parameters:  
//
// Output:      NA
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Compare based on iTotalElementsCovered field in descending order
int compareStructsDesc(const void *a, const void *b)
{
    return ((struct st_coveringResultSupport*)b)->iTotalElementsCovered - ((struct st_coveringResultSupport*)a)->iTotalElementsCovered;
}

// Compare based on coverageCost field in ascending order
int compareCoverageCostAsc(const void *a, const void *b)
{

    float diff = ( ((struct st_coverageCostSupport*)a)->coverageCost - ((struct st_coverageCostSupport*)b)->coverageCost );

    return (diff > 0) ? 1 : ((diff < 0) ? -1 : 0);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fgerResultSupport
//
// Description: Local Search function
//
// Parameters:  nElements       - number of Elements
//              nSubSets        - number of SubSets
//              psubSets        - pointer to the class subSet
//              pelements       - pointer to the class element
//              pcoveringResult - covering result
//              iNumberMaxExecution - Max number of executions
//
// Output:      Return the number of SubSets used
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int fgerResultSupport( int nSubSets, subSet *psubSets, coveringResult *pcoveringResult, struct st_coveringResultSupport *pst_coveringResultSupport )
{
    int inumOfCovering     = pcoveringResult[0].fgetNumOfCovering();
    int *subSets           = new int[inumOfCovering];
    int *elements          = new int[inumOfCovering];
    int *weight            = new int[inumOfCovering];
    int *subSetsVisited    = new int[nSubSets];
    int icoveringResultSupport = 0;
    int iPrioritySubSet    = 0;
    int iGreaterCovering   = 0;
    coveringResult *newCoveringResult = new coveringResult[1];



    // Set with 0 a vector with SubSets visited
    for(int i=0;i<nSubSets;i++) subSetsVisited[i]=0;

    // Get all SubSets of previous solution
    subSets  = pcoveringResult[0].fgetSubSets();
    elements = pcoveringResult[0].fgetElements();
    weight   = pcoveringResult[0].fgetWeight();

    // Reading all SubSets with purpose to have a distinc list of SubSets and number of covering for each one.
    for(int i=0;i<inumOfCovering;i++)
    {

       if(subSetsVisited[(subSets[i]-1)]==0)
       {
          pst_coveringResultSupport[icoveringResultSupport].SubSet = subSets[i];	

	  subSetsVisited[(subSets[i]-1)]=1;

	  icoveringResultSupport++;
       }
       else
          subSetsVisited[(subSets[i]-1)]=subSetsVisited[(subSets[i]-1)]+1;

    }

    // Associate the SubSets with covering number
    for(int i=0;i<icoveringResultSupport;i++)
    {
        pst_coveringResultSupport[i].iTotalElementsCovered=subSetsVisited[(pst_coveringResultSupport[i].SubSet-1)];

	if(pst_coveringResultSupport[i].iTotalElementsCovered>iGreaterCovering)
	{
 	   iGreaterCovering=pst_coveringResultSupport[i].iTotalElementsCovered;
	   iPrioritySubSet=pst_coveringResultSupport[i].SubSet;
	}

    }

    return(icoveringResultSupport);
/*
    std::cout << std::left;
    std::cout << "\n";
    std::cout << "***********************************************************************\n";
    std::cout << "Order by Number of Covering" << "\n";
    std::cout << "---------------------------" << "\n";
    std::cout << std::setw(14) << "SubSet";
    std::cout << std::setw(14) << "Number of Covering" << "\n";
    std::cout << std::setw(14) << "------";
    std::cout << std::setw(14) << "------------------" << "\n";

    for(int i=0;i<icoveringResultSupport;i++)
    {
        std::cout << std::setw(14) << pst_coveringResultSupport[i].SubSet;
        std::cout << std::setw(14) << pst_coveringResultSupport[i].iTotalElementsCovered << "\n";
    }
    std::cout << "***********************************************************************\n";
*/
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fgerRandomic
//
// Description: Random number generation
//
// Parameters:  iRange - Range to generate randomic number
//
// Output:      Randomic number generate
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int fgerRandomic( int iRange )
{
    int random_number = 0;

    // Create a random number generator engine
    std::mt19937 rng(std::random_device{}());

    // Define a distribution
    std::uniform_int_distribution<int> distribution(0, (iRange-1)); 

    // Generate random number
    random_number = distribution(rng);

    return(random_number);
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fsetInfoReports
//
// Description: Registering process time
//
// Parameters:  pReportScp - Class with process informations
//              EndProcess - Flag that informs if the process is at begining or at the end
//
// Output:      NA
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void fsetInfoReports( ReportScp *pReportScp, bool EndProcess ) 
{
    struct        tms tmsprocess;
    clock_t       start_e_end;
    static long   clktck = 0;

    clktck = sysconf(_SC_CLK_TCK);

    start_e_end = times(&tmsprocess);

    if (!EndProcess) {

       ////////////////////
       // Initial times
       ///////////////////
       pReportScp->setStartRealTime(start_e_end);
       pReportScp->setStartUserCPUTime(tmsprocess.tms_utime);
       pReportScp->setStartSystemCPUTime(tmsprocess.tms_stime);

    }
    else
    {

       ////////////////////
       // End times
       // /////////////////
       pReportScp->setEndRealTime(start_e_end);
       pReportScp->setEndUserCPUTime(tmsprocess.tms_utime);
       pReportScp->setEndSystemCPUTime(tmsprocess.tms_stime);
       

       ////////////////////
       // Duration times
       // /////////////////
       pReportScp->setRealTimeDuration( (pReportScp->getEndRealTime()-pReportScp->getStartRealTime()) / (double)clktck );
       pReportScp->setUserCPUDuration( (pReportScp->getEndUserCPUTime()-pReportScp->getStartUserCPUTime()) / (double)clktck );
       pReportScp->setSystemDuration( (pReportScp->getEndSystemCPUTime()-pReportScp->getStartSystemCPUTime()) / (double)clktck );

    }

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Function: fpostProcessing
//
// Description: Treating redundant sets
//
// Parameters:  nElements        - number of Elements
//              nSubSets         - number of SubSets
//              psubSets         - pointer to the class subSet
//              pelements        - pointer to the class element
//              pcurrentSolution - current Solution	
//
// Output:      result of covering without redundant sets
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
coveringResult *fpostProcessing( int nElements, int nSubSets, subSet *psubSets,  element *pelements, coveringResult *pcurrentSolution )
{

    int iBreakPoint = 0;
    int iPosActual  = 0;
    int iNewSubSet  = 0;
    int iNewWeight  = 0;
    int numSetsPerElement = 0;
    int inumOfCovering = pcurrentSolution[0].fgetNumOfCovering();          // Number of covering
    coveringResult *newSolution  = new coveringResult[1];                  // New solution
    int *subSets                 = new int[inumOfCovering];
    int *elements                = new int[inumOfCovering];
    int *weight                  = new int[inumOfCovering];


    // Get all SubSets, Elements and Weights of the current solution
    subSets  = pcurrentSolution[0].fgetSubSets();
    elements = pcurrentSolution[0].fgetElements();
    weight   = pcurrentSolution[0].fgetWeight();


    // New solution receives the current solution
    newSolution[0] = pcurrentSolution[0];


    // Get the first iBreakPoint and iNewSubSet
    iNewSubSet = subSets[iBreakPoint];

    while( iBreakPoint < inumOfCovering && iNewSubSet==subSets[iBreakPoint]  )
	    iBreakPoint++;

    iNewSubSet = subSets[iBreakPoint];
    ///////////////////////////////////


    while( iPosActual < inumOfCovering )
    {

       iPosActual = 0;

       while( iPosActual < inumOfCovering && iPosActual < iBreakPoint )
       {

             // Get number of SubSets for this Element
	     numSetsPerElement = pelements[(elements[iPosActual]-1)].fgetNumOfSets(); 

             // Get all SubSets for this Element
	     int *pSetsPerElement  = new int[numSetsPerElement];
 	     pSetsPerElement = pelements[(elements[iPosActual]-1)].fgetSubSets();         

             // Reading all Subsets for Element and looking for a new one
             // differente from the current, if possible.
	     for(int i=0;i<numSetsPerElement;i++)         
	     {                                            

		    // Found the SubSet and:
                    if( pSetsPerElement[i]==iNewSubSet )
		    {

			 // Get the weight for the new SubSet   
                         iNewWeight = psubSets[(pSetsPerElement[i]-1)].fgetWeight(); 

			 // Update in the Element, the new Weight
		         newSolution[0].fupdWeight(iNewWeight,iPosActual);

			 // Update in the Element, the new Set
			 newSolution[0].fupdSubSet(iNewSubSet,iPosActual);

  			 break;

		    }
			
	      }

	      delete pSetsPerElement;

	      iPosActual++;     

       }

       // Update the iNewSubSet with the SubSet used before
       iNewSubSet = subSets[iBreakPoint];

       // Getting the new iBreakPoint and the new SubSet to the next looping
       while( iBreakPoint < inumOfCovering && iNewSubSet==subSets[iBreakPoint]  )
          iBreakPoint++;

       // But if the iBreakPoint reached the number of inumOfCovering, break and end of the changing
       if( iBreakPoint == inumOfCovering )
          break;

       iNewSubSet = subSets[iBreakPoint];


    }

    /////////////////////////////////////////////////////
    // Calculate the Total Weight and Total SubSets used
    int *newSubSets     = new int[inumOfCovering];
    int *newWeight      = new int[inumOfCovering];
    int *subSetsVisited = new int[nSubSets];
    int iTotWeight      = 0;
    int iTotSetSub      = 0;

    // Set all SubSetsVisited with 0
    for(int i=0;i<nSubSets;i++) subSetsVisited[i]=0;

    newSubSets = newSolution[0].fgetSubSets();
    newWeight  = newSolution[0].fgetWeight();

    for(int i=0;i<inumOfCovering;i++)
    {
       if( subSetsVisited[ (newSubSets[i]-1) ] == 0 )
       {
           subSetsVisited[ (newSubSets[i]-1) ] = 1;
           iTotSetSub++;
	   iTotWeight = iTotWeight + newWeight[i];
       }
    }

    delete newSubSets;
    delete newWeight;
    delete subSetsVisited;

    // Update the Total Weight and Total SubSets used
    newSolution[0].fsetTotalWeight(iTotWeight);
    newSolution[0].fsetTotalSubSetsUsed(iTotSetSub);
    /////////////////////////////////////////////////////


    return(newSolution);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
